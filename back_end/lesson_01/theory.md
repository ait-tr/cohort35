# Lesson 01

### Лекция 1: Многопоточность. Введение

#### Общие Сведения
- Многопоточность требует изменения мышления в программировании.
- Традиционно, программы выполнялись последовательно, но многопоточность вводит понятие параллельности.

#### 1.1 Введение
- Рассматривается эволюция вычислительных машин, начиная с XIX века.
- Упоминается "закон" Мура о росте числа транзисторов на кристалле.
- Изначально процессоры были одноядерными; многозадачность достигалась за счет быстрого переключения процессора между задачами.
- Развитие процессоров привело к увеличению числа ядер для повышения производительности.

#### 1.2 Краткое описание работы процессора
- АЛУ (арифметико-логическое устройство) — ключевой элемент процессора.
- АЛУ выполняет базовые операции: чтение, запись, сложение, логические операции и др.
- Операции в процессоре не атомарны и могут быть прерваны.

#### 1.3 Поддержка на уровне операционной системы
- **Простое переключение задач**: Без приоритетов, подходит для однопоточной среды.
- **Кооперативная многозадачность**: Задачи сами определяют, когда отдать управление.
- **Вытесняющая многозадачность**: ОС контролирует переключение задач, учитывая приоритеты и события.

#### 1.4 Процессы и потоки
- **Процесс**: Исполняемая программа с собственными ресурсами.
- **Поток**: Минимальная единица обработки внутри процесса, потоки могут делить ресурсы внутри процесса.

#### Многопоточность и алгоритм разделения времени
- Алгоритм time-slicing распределяет время процессора между потоками.
- В многоядерных процессорах потоки могут выполняться действительно параллельно.

#### Преимущества и недостатки многопоточности
- **Преимущества**: Улучшает адаптивность приложений, эффективнее использует ресурсы, повышает производительность.
- **Недостатки**: Требует синхронизации данных, сложность в проектировании и отладке, издержки на переключение контекста.

#### 2.1 Средства для работы с многопоточностью в Java
- **Java 1.0**: `Thread`, `Runnable`, `synchronized`, `wait()`, `notify()`, `notifyAll()`.
- **Java 1.5**: Пакет `java.util.concurrent` с расширенными возможностями.
- **Java 1.8**: `CompletableFuture` для асинхронных задач и их комбинирования.

#### Модели многопоточных программ
- Синхронизация, блокировки, `volatile`.
- Транзакционная память, рекурсивный параллелизм.
- Модель акторов: объекты как потоки обмениваются сообщениями.
#### Проблемы, решаемые многопоточностью (продолжение)

1. **Одновременное выполнение нескольких действий**: Многопоточность позволяет программе выполнять несколько задач одновременно, улучшая интерактивность и отзывчивость.
2. **Ускорение вычислений**: Использование многопоточности позволяет эффективно распределить задачи между ядрами процессора, сокращая общее время выполнения программы.

#### Проблемы, создаваемые многопоточностью

1. **Взаимная блокировка (Deadlock)**: Состояние, при котором два или более потоков ждут ресурсы, захваченные друг другом, и не могут продолжить выполнение.
2. **Состояние гонки (Race Condition)**: Ошибка проектирования, когда работа системы становится зависимой от последовательности выполнения потоков. Это может привести к непредсказуемому поведению программы.

#### Что должен знать Java-разработчик о многопоточности

**Уровень Junior**:
- Основы реализации многопоточности в Java.
- Синтаксические конструкции, связанные с потоками.
- Основы пакета `java.util.concurrent`.

**Уровень Middle**:
- Глубокое понимание стандартных библиотек и инструментов Java для многопоточности.
- Понимание многопоточности в контексте Spring.
- Способность самостоятельно разрабатывать многопоточный функционал.

**Уровень Senior**:
- Продвинутое знание инструментов и библиотек для многопоточности.
- Понимание применения инструментов многопоточности в различных сценариях.
- Умение архитектурно интегрировать многопоточность в приложения.

