## Повторение

* `Функциональные интерфейсы` - интерфейс с одним методом
* Какие плюсы? - можно явно не прописывать полную реализацию интерфейса

## Задача

* Пусть у меня имеется некоторый набор точек в трехмерном пространстве:

(4, 1, 5)
(6, 2, 8)
(10, 11, 15)
(15, 2, 5)

* Это может быть например перемещение какого объекта в воздухе
* Ваша задача - распечатать этот набор разными способами
* Сделать программу такой, чтобы эти способы печати можно было менять

## Решение

1) Для начала сделаем некоторый класс, который назовем Point и он будет хранить в себе эти три точки
2) Я логику преобразования трех чисел в строку переложу в отдельный модуль (класс и т.д.), отделю ее от `PointsPrinter`
3) Мы сделаем отдельный функциональный интерфейс `Convert`, в котором мы опишем один единственный метод:
  * Метод принимает на вход три числа, возвращает строку

### Анонимные классы

* Иногда вы не хотите создавать отдельный файл для какой-либо логики
* Потому что эта логика нужна ТОЛЬКО В ОДНОМ МЕСТЕ
* Тогда имеет смысл сделать анонимный класс
* Создание анонимного класса базируется на наследовании или имплементации
  * То есть вы не будете создать отдельный файл, в котором вы реализуете определенные методы
  * Вы сразу создадите объект на основе класса-предка или интерфейса в нужном месте
  * Вам просто надо реализовать его методы (абстрактные)
* Анонимным классом можно реализовать любой абстрактный класс или интерфейс

### Лямбда-выражения

* Если у нас с вами в интерфейсе только один метод (он функциональный), то нет смысла прописывать полную реализацию его метода
* Можно много чего сократить и получить "лямбда-выражение"
* Т.е. лямбда-выражение - это анонимная реализация единственного метода функционального интерфейса

### Тезисы

* Если в коде возникает какая-то функциональная операция (в нашем случае, это преобразование трех чисел в строку)
  * Имеет смысл сделать функциональный интерфейс для этой операции
  * Далее, на основе этого интерфейса делать лямбда-выражения и передавать их как аргументы для других методов 

* Рассмотрим интерфейс:

```
public interface Convert {

    String from(int a, int b, int c);
}
```

* Пример краткой записи лямбда выражения:

```
(x, y, z) ->  "Point in (" + x + ", " + y + ", " + z + ")"
```

* Здесь `(x, y, z)` - параметры (они соответствуют параметрам оригинального метода функционального интерфейса)
* `"Point in (" + x + ", " + y + ", " + z + ")"` - тело выражения (реализация метода)

* Пример полной записи:

```
(x, y, z) ->  {
  return "Point in (" + x + ", " + y + ", " + z + ")";
}
```

* Если несколько строк в реализации используем фигурные скобки и `return`

### Встроенные функциональные интерфейсы и их использование

* Рассмотрим код

```
    public MyArrayList<Integer> filter(MyArrayList<Integer> list) {
        // список целых чисел "отфильтрованный"
        MyArrayList<Integer> result = new MyArrayList<>();

        for (int i = 0; i < list.size(); i++) { // пробегаем исходный список
            if (list.get(i) > 0) {
                result.add(list.get(i));
            }
        }

        return result;
    }
```

* Мы видим, что гибким моментом может быть как-раз проверка условия
* Следовательно, надо как-то научиться передавать это условие в параметр метода
* Условие в if - это по сути какое-то выражение, которое возвращает либо `true`, либо `false`
  * для объекта `list.get(i)`
* Поэтому мы можем использовать встроенный функциональный интерфейс `Predicate`

* Предикат

```
public interface Predicate<T> {

   boolean test(T t); // метод, который для объекта t вовзращает true или false
}
```

## Какие есть числа

* Большое множество действительных чисел (вообще все числа, кроме комплексных)
  * Целые числа   
    * Отрицательные
    * Положительные ~ Натуральные числа (1, 2, 3, 4, ...)
    * 0
  * Рациональные - 1/3
  * Иррациональные - pi, e ~ 2.718281828....

## Enums

* Enum - перечисление, позволяет определить набор именованных констант. Делает код более читаемым и поддерживаемым.

### Жизнь без ENUM

* Можем использовать строки

* `private String role` - можно вписать что угодно и не факт, что правильно

* Можем использовать числа

* `private Integer role` - опять можем вписать любое число + код становится нечитаемым и не очевидным

* А если попробовать константы:

```
public class UserRole {
    
    public static final String ADMIN = "ADMIN";
    public static final String MANAGER = "MANAGER";
    public static final String CLIENT = "CLIENT";
}
```

```
User user = new User();
user.setRole(UserRole.ADMIN);
```

* А какой минус?

```
user.setRole("ERUNDA");
```

* Решение - написать валидацию прям внутри set-ера, но, это не гарантирует, что какой-либо метод самого класса не захочет туда положить ерунду.

### Лучшее решение - использовать enum

* Именованный набор констант
* Автоматически существуют ограничения на возможные значения

[Лекция Кирилла](https://lms.ait-tr.de/#/lessons/group/cohort27/module/basic_programming/lesson/lesson_51)