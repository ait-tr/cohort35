Сегодня мы поговорим об инкапсуляции в Java.
И начнем с примеров :)

Представьте, перед вами кофемашина.

И у меня парочка вопросов? А как это работает? Какая температура воды нужна для приготовления кофе? А сколько воды, молока? А как в нашу чашку попадает молочная пена, а не молоко? А как вообще варится кофе, прямо из целых зерен, которые мы засыпали? А сколько кофе нужно для 1 порции кофе?

Вероятнее всего, ответов на эти вопросы у вас нет. Хорошо, возможно не все пользуются такими автоматами. Попробую привести другой пример. Что-нибудь, чем вы точно пользуетесь много раз каждый день.
Например, Google.

Расскажите, как работает поисковик Google. Как именно он ищет информацию по тем словам, которые вы ввели? Почему наверху находятся эти результаты, а не другие?

Хотя вы пользуетесь гуглом каждый день, скорее всего, вы этого не знаете. Но это не важно. Ведь **нам и не нужно этого знать**.

Вы можете вводить запросы в поисковик не задумываясь, как именно он работает. Вы можете выпить чашечку кофе, не зная как устроена кофемашина. Вы можете водить машину, не вникая в работу двигателя, и вообще не зная физику и механику.

Все это возможно благодаря одному из принципов объектно-ориентированного программирования — **инкапсуляции**

В программировании есть два распространенных понятия — **инкапсуляция** и **сокрытие**. И под словом «инкапсуляция» авторы понимают то одно, то другое (так уж сложилось).
Мы разберем оба понятия.

Изначальное значение слова **«инкапсуляция»** в программировании — объединение данных и методов работы с этими данными в одной упаковке («капсуле»)

В Java в роли упаковки-капсулы выступает **класс**. Класс содержит в себе и данные (поля класса), и методы для работы с этими данными.

В ООП программы состоят из классов-капсул, которые являются одновременно и данными, и методами для работы с ними. И наш резиновый массив, который мы писали на прошлом уроке - типичный пример класса-капсулы.

Теперь поговорим о **сокрытии**.

Как же так получается, что мы пользуемся всякими сложными механизмами без понимания, как они устроены и на чем основана их работа? Все просто: их создатели предоставили простой и удобный интерфейс.
На кофемашине интерфейс — это кнопки на панели. Нажав одну кнопку, вы получаете эспрессо. Нажав вторую, выбираете капучино. Третья отвечает за больший объем порции. И это все, что нам нужно сделать.

Неважно, как именно кофемашина устроена внутри. Главное — она устроена так, что **для получения порции кофе пользователю нужно нажать кнопку**.

Именно в этом заключается суть сокрытия. Все «внутренности» программы скрываются от пользователя. Для него эта информация является лишней, ненужной. Пользователю необходим конечный результат, а не внутренний процесс.

Давайте для примера напишем класс Auto:

```
// Тут будет код класса Auto

```

Вот как выглядит сокрытие реализации в Java-программе. Все как в реальной жизни: пользователю предоставлен интерфейс (методы). Если ему нужно, чтобы автомобиль в программе выполнил действие, достаточно вызвать нужный метод. А уж что там происходит внутри этих методов — информация лишняя, главное, чтобы все работало как надо.

Здесь мы говорили про сокрытие реализации. Кроме него в Java есть еще сокрытие данных.

Давайте потренируемся на кошках. Напишем класс Cat2:

```
public class Cat2 {
   
   public String name;
   public int age;
   public int weight;


   public Cat2(String name, int age, int weight) {
       this.name = name;
       this.age = age;
       this.weight = weight;
   }

   public Cat2() {
   }

   public void sayMeow() {
       System.out.println("Мяу!");
   }
}
```

Проблема класса в том, что его данные (поля) открыты для всех, и другой программист легко может создать в программе кота без имени с весом 0 и возрастом -1000 лет

```
public static void main(String[] args) {
  
   Cat2 cat = new Cat2();

   cat.name = "";
   cat.age = -1000;
   cat.weight = 0;
}
```

С **сокрытием данных** нам помогают:

- модификаторы доступа (private, protected, package default);
- геттеры и сеттеры

В Java используются следующие модификаторы доступа:

- **public**: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны всем классам из текущего пакета и из внешних пакетов.
- **private**: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.
- **protected**: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах
- **package default** - Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

Авторы разных статей об инкапсуляции имеют в виду либо инкапсуляцию (объединение данных и методов), либо сокрытие, либо **и то, и другое**. В Java присутствуют оба механизма (в других ООП-языках это не обязательно так), так что последний вариант будет наиболее правильным.

Использование инкапсуляции дает нам несколько важных преимуществ:

- Контроль за корректным состоянием объекта. Примеры этому были выше: благодаря сеттеру и модификатору private, мы обезопасили нашу программу от котов с весом 0.
- Удобство для пользователя за счет интерфейса. Мы оставляем «снаружи» для доступа пользователя только методы. Ему достаточно вызвать их, чтобы получить результат, и совсем не нужно вникать в детали их работы.
- Изменения в коде не отражаются на пользователях. Все изменения мы проводим внутри методов. На пользователя это не повлияет: он как писал auto.gas() для газа машины, так и будет писать. А то, что мы поменяли что-то в работе метода gas() для него останется незаметным: он, как и раньше, просто будет получать нужный результат.











